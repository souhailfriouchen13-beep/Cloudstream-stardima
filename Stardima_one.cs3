import com.lagradost.cloudstream3.*
import com.lagradost.cloudstream3.utils.*
import com.lagradost.cloudstream3.network.*

// Stardima.one Cloudstream extension
class StardimaOne : MainAPI() {
    override val name = "Stardima.one"
    override val mainUrl = "https://stardima.one"
    override val lang = "ar"       // site language (change if needed)
    override val supportedTypes = setOf(TvType.Anime, TvType.Other)
    override val hasMainPage = true

    // MAIN PAGE (popular / latest) - optional but helpful
    override suspend fun getMainPage(page: Int, request: MainPageRequest): HomePageResponse {
        val url = if (page <= 1) mainUrl else "$mainUrl/page/$page"
        val document = app.get(url).document
        val cards = mutableListOf<HomePageList>()
        val items = document.select("article.post, .anime_post, .post") // try a few patterns
        val listItems = items.map { el ->
            val a = el.selectFirst("a") ?: el
            val title = el.selectFirst("h2, h3, .title")?.text().orEmpty()
            val href = a.attr("href")
            val poster = el.selectFirst("img")?.attr("src").orEmpty()
            MovieSearchResponse(title, href, poster)
        }
        cards.add(HomePageList(request.name ?: "Latest", listItems))
        return HomePageResponse(cards)
    }

    // SEARCH
    override suspend fun search(query: String): List<SearchResponse> {
        // Many WP sites support ?s= search
        val searchUrl = "$mainUrl/?s=${query.replace(" ", "+")}"
        val document = app.get(searchUrl).document
        val results = mutableListOf<SearchResponse>()

        // Common result card patterns
        val entries = document.select("article.post, .anime_post, .result, .item")
        if (entries.isEmpty()) {
            // fallback: search results container
            document.select(".search-results li a").forEach { el ->
                val title = el.text()
                results.add(SearchResponse(title, el.attr("href"), ""))
            }
        } else {
            entries.forEach { el ->
                val a = el.selectFirst("a")
                val title = el.selectFirst("h2, h3, .title")?.text() ?: a?.text() ?: ""
                val href = a?.attr("href") ?: ""
                val poster = el.selectFirst("img")?.attr("src") ?: ""
                if (href.isNotEmpty()) results.add(SearchResponse(title, href, poster))
            }
        }
        return results
    }

    // LOAD (page for a show / movie) - collect metadata + episode list
    override suspend fun load(url: String): LoadResponse {
        val document = app.get(url).document
        val title = document.selectFirst("h1.entry-title, h1.post-title, .title")?.text().orEmpty()
        val poster = document.selectFirst("img.wp-post-image, .post-thumbnail img")?.attr("src").orEmpty()
        val description = document.selectFirst(".entry-content, .post-content, .description")?.text().orEmpty()

        // Episode list - try common patterns used by streaming WP themes
        val episodes = mutableListOf<Episode>()
        // pattern 1: list of episode links
        document.select("ul.episodes li a, .episodes a, .episode_list a, .eps a").forEachIndexed { idx, el ->
            val epTitle = el.text().ifEmpty { "Episode ${idx + 1}" }
            val epUrl = el.attr("href")
            episodes.add(Episode(epTitle, epUrl, epUrl))
        }

        // pattern 2: if episodes are links inside .episodes-wrap or .server-list
        if (episodes.isEmpty()) {
            document.select("a[href*='episode'], a[href*='ep-']").forEachIndexed { idx, el ->
                episodes.add(Episode(el.text().ifEmpty { "Episode ${idx + 1}" }, el.attr("href"), el.attr("href")))
            }
        }

        // If still empty and the page itself is an episode page, add the page as single episode
        if (episodes.isEmpty()) {
            episodes.add(Episode(title, url, url))
        }

        val info = loadPosterLinks(poster)
        return LoadResponse(
            title = title,
            url = url,
            type = TvType.Anime,
            poster = poster,
            description = description,
            episodes = episodes,
            tags = emptyList()
        )
    }

    // LOAD LINKS (resolve playable links) - returns direct videos (m3u8, mp4, or iframe src)
    override suspend fun loadLinks(
        data: String,
        isCasting: Boolean,
        subtitleCallback: (Subtitle) -> Unit
    ): List<Video> {
        // data is episode page URL
        val doc = app.get(data).document

        // 1) Look for iframe players (common)
        val iframeSrc = doc.selectFirst("iframe[src]")?.attr("src")
        if (!iframeSrc.isNullOrEmpty()) {
            // If iframe is relative, resolve to absolute
            val finalIframe = if (iframeSrc.startsWith("http")) iframeSrc else mainUrl.trimEnd('/') + iframeSrc
            // Try direct return, Cloudstream may handle many hosts; otherwise extra extractors are needed.
            return listOf(Video(finalIframe, "iframe", finalIframe))
        }

        // 2) Look for <video> sources
        val videoSource = doc.selectFirst("video source")?.attr("src")
        if (!videoSource.isNullOrEmpty()) {
            val v = if (videoSource.startsWith("http")) videoSource else mainUrl.trimEnd('/') + videoSource
            return listOf(Video(v, "video", v))
        }

        // 3) Look for .m3u8 or mp4 links inside scripts or data attributes
        val scriptText = doc.select("script").joinToString("\n") { it.html() }
        val m3u8Regex = Regex("""(https?:\/\/[^\s'"]+\.m3u8[^\s'"]*)""")
        val mp4Regex = Regex("""(https?:\/\/[^\s'"]+\.mp4[^\s'"]*)""")

        val m3u8Match = m3u8Regex.find(scriptText)
        if (m3u8Match != null) {
            val url = m3u8Match.groupValues[1]
            return listOf(Video(url, "hls", url))
        }
        val mp4Match = mp4Regex.find(scriptText)
        if (mp4Match != null) {
            val url = mp4Match.groupValues[1]
            return listOf(Video(url, "mp4", url))
        }

        // 4) Fallback: search for data-src attributes or source in HTML
        val dataSrc = doc.selectFirst("[data-src]")?.attr("data-src")
        if (!dataSrc.isNullOrEmpty()) return listOf(Video(dataSrc, "data-src", dataSrc))

        // Nothing found
        return emptyList()
    }

    // Optional: custom extractor helpers can be added here if stardima.one uses a special host
}